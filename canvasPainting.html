<html>
<head>
    <style>
        #wrapper {
            position: relative;
            width: 900px;
            height: 500px;
        }

        #over_map {
            position: absolute;
            top: 80px;
            right: 0;
            width: 200px;
            height: 100px;
            border: 3px solid #73AD21;
            z-index: 99;
            color: red;
        }

        #myCanvas {
            position: absolute;
            top: 0px;
            left: 0;
            z-index: 98;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
    <style>
        table {
            border-collapse: collapse;
        }

        table, td, th {
            border: 1px solid black;
        }
    </style>
    <!--Element Resize Listener Libraries - http://marcj.github.io/css-element-queries/-->
    <script src="ResizeSensor.js"></script>
    <script src="ElementQueries.js"></script>
    <script src="http://maps.googleapis.com/maps/api/js"></script>
    <script>
        //TODO APPEND BEFORE FOR CONSOLE OUTPUT - DONE
        //TODO TIMER FOR MAP REFRESH - DONE BY USING idle listener event of maps API
        //TODO DISPLAY SOURCES LATITUDES, LONGITUDES SERVICE NAMES POINT IDS VALUES IN A TABLE - DONE
        //TODO CREATE AN EVAL BOX FOR DEBUGGING

        <!--Map Setting Script-->
        //var myCenter = new google.maps.LatLng(22.532853026644325,78.16772421874998);
        var myCenter;
        var marker;
        var map;
        var ctx;
        var c;
        var xp;
        var yp;
        var ne;
        var sw;
        var latx1;
        var latx2;
        var longy1;
        var longy2;
        var lat_width;
        var long_hgt;
        var npx;
        var npy;
        var npxRatioSquare;
        var sources = [[22.532853026644325, 78.16772421874998, 1.5], [21.2016592, 81.1051448, 1.1]];
        var alpha = 1.5;
        var transparency = 80;//between 0 - 255
        var canvasData = [];
        var normalisedCanvasData = [];
        var imageData = [];
        var minVal;
        var maxVal;
        var valDiff;
        var maxHue = 120;
        var minHue = 0;
        var hueDiff = maxHue - minHue; //Lets go for red color for now
        var xpsource;
        var ypsource;
        var vsource;
        var mConsole;
        var mSourceTable;

        //http://gomakethings.com/a-native-javascript-equivalent-of-jquerys-ready-method/
        //https://developer.mozilla.org/en/docs/web/api/document/readystate
        // alternative to DOMContentLoaded event
        document.onreadystatechange = function () {
            if (document.readyState == "interactive") {
                domReady();
            } else if (document.readyState == "complete") {
                //DOM load initialization function
                google.maps.event.addDomListener(window, 'load', mapSourceLoaded);
            }
        };

        //Utility Functions
        function doStyling(style, tag) {
            style.display = 'block';
            style.fontSize = '0.9em';
            style.fontFamily = "Courier New";
            if (tag == 'error') {
                style.color = 'red';
            } else if (tag == 'warning') {
                style.color = '#FF8C00';
            } else if (tag == 'info') {
                style.color = 'blue';
            } else if (tag == 'success') {
                style.color = 'blue';
            }
        }

        //Utility Functions
        function WriteLineConsole(str, tag) {
            var currentDate = new Date();
            var para = document.createElement("span");
            var n = currentDate.getDate() + "/"
                    + (currentDate.getMonth() + 1) + "/"
                    + currentDate.getFullYear() + " @ "
                    + currentDate.getHours() + ":"
                    + currentDate.getMinutes() + ":"
                    + currentDate.getSeconds() + " - ";
            var node = document.createTextNode(n + str);
            para.appendChild(node);
            //mConsole.appendChild(para);
            mConsole.insertBefore(para, mConsole.firstChild);
            doStyling(para.style, tag);
        }

        //Utility Functions
        function clearConsole(str, tag) {
            mConsole.innerHTML = "";
        }

        //Utility Functions
        function addSourcesToTable() {
            for (var i = 0; i < sources.length; i++) {
                addRow(i + 1, "Name", sources[i][0], sources[i][0], sources[i][0]);
            }
        }

        //Utility Functions
        function addRow() {
            var rowCount = mSourceTable.rows.length;
            //var colCount = table.rows[0].cells.length;
            var row = mSourceTable.insertRow(rowCount);//if row to inserted at last then insert at rowCount
            for (var i = arguments.length - 1; i >= 0; i--) {
                //alert(arguments[i]);
                var newCell = row.insertCell(0);
                var t = document.createTextNode(arguments[i]);
                var s = document.createElement("span");
                s.appendChild(t);
                newCell.appendChild(s);
            }
            //row inserted in to the table
        }
        //Utility Functions
        function clearTable() {
            mSourceTable.innerHTML = "";
        }

        //Utility Functions
        //Numeric text input listener
        //http://stackoverflow.com/questions/33251052/allow-only-numbers-and-ctrla-ctrlv-ctrlc-to-a-textbox
        function numericListener(e) {
            // Allow: backspace, delete, tab, escape, enter and .
            if ([46, 8, 9, 27, 13, 110, 190].indexOf(e.keyCode) !== -1 ||
                        // Allow: Ctrl+A
                    (e.keyCode == 65 && e.ctrlKey === true) ||
                        // Allow: Ctrl+C
                    (e.keyCode == 67 && e.ctrlKey === true) ||
                        // Allow: Ctrl+X
                    (e.keyCode == 88 && e.ctrlKey === true) ||
                        // Allow: home, end, left, right
                    (e.keyCode >= 35 && e.keyCode <= 39)) {
                // let it happen, don't do anything
                return;
            }
            // Ensure that it is a number and stop the keypress
            if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
                e.preventDefault();
            }
        }

        //Utility Functions
        function showHide(el, txt1, txt2) {
            //Toggle Display button for the table
            var div = findSibling(el, "hidingClass");
            if (div.style.display !== "none") {
                div.style.display = "none";
                el.textContent = txt1;
            } else {
                div.style.display = "block";
                el.textContent = txt2;
            }
        }

        //Utility Functions
        function findSibling(el, cls) {
            while (!el.classList.contains(cls)) {
                el = el.nextElementSibling;
            }
            return el;
        }

        //Utility Functions
        function isNumberKey(evt) {
            //charcodes info http://www.cambiaresearch.com/articles/15/javascript-key-codes
            evt = (evt) ? evt : window.event;
            var charCode = (evt.which) ? evt.which : evt.keyCode;
            if (charCode < 32 || (charCode > 47 && charCode < 58) || (charCode == 46)) {
                return true;
            }
            return false;
        }

        /*LatLong to pixel conversion function*/
        function LatLongToPixelCoordinates(latx, longy) {
            return [parseInt((xp / lat_width) * (longy - latx1)), parseInt((yp / long_hgt ) * (longy2 - latx))];
            //return [parseInt((xp/lat_width)*(latx - latx1),10), parseInt((yp/long_hgt )*(longy-longy1),10)];
        }

        /*Get all Voltage sources locations and p.u values as a [nx3] array */
        function getVoltagePoints() {
            // [[1,2],[3,4]];//items[0][0] = 1
            return sources;
        }

        //Compute Canvas Parameters - Do this if canvas measurements change
        function computeCanvasParams() {
            //get Console and SourceTable objects
            mConsole = document.getElementById("console");
            mSourceTable = document.getElementById("mSourceTable");

            //Canvas initialization
            ctx = c.getContext("2d");
            ctx.strokeStyle = 'blue';
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            //ctx.fillStyle = "blue";
            //ctx.fillStyle = "rgb(255, 0, 0)";
            //Get the Width and LengtSTUh of canvas
            xp = getComputedStyle(c, null).getPropertyValue('width');
            xp = xp.substring(0, xp.length - 2);
            ctx.canvas.width = xp;
            yp = getComputedStyle(c, null).getPropertyValue('height');
            yp = yp.substring(0, yp.length - 2);
            ctx.canvas.height = yp;
            WriteLineConsole("*********************************", "warning");
            WriteLineConsole("Writing DIV dimensions in pixels");
            WriteLineConsole("Width of div is " + xp, "info");
            WriteLineConsole("Height of div is " + yp, "info");
            //WriteLineConsole("*********************************", "info");
        }

        //After the canvas bounds can be measured and when canvas bounds are changed
        function onMapStateChanged() {
            //get map bounds
            ne = map.getBounds().getNorthEast();//topRight
            sw = map.getBounds().getSouthWest();//bottomLeft
            latx1 = sw.lng();
            latx2 = ne.lng();
            longy1 = sw.lat();
            longy2 = ne.lat();
            //View Port Width in degrees
            lat_width = latx2 - latx1;
            long_hgt = longy2 - longy1;
            //No of degrees per pixel on X axis
            npx = lat_width / xp;
            //No of degrees per pixel on Y axis
            npy = long_hgt / yp;
            //npxRatio = npy/npx;
            npxRatioSquare = (npy * npy) / (npx * npx);
            sources = getVoltagePoints();
            WriteLineConsole("*********************************", "warning");
            WriteLineConsole("Writing DIV dimensions in degrees");
            WriteLineConsole("Width of div is " + lat_width, "info");
            WriteLineConsole("Height of div is " + long_hgt, "info");
            WriteLineConsole("Longitude bounds are " + latx1 + " and " + latx2, "info");
            WriteLineConsole("Latitude bounds are " + longy1 + " and " + longy1, "info");
            WriteLineConsole("degrees / pixel on X axis is " + npx, "info");
            WriteLineConsole("degrees / pixel on Y axis is " + npy, "info");
            //WriteLineConsole("*********************************", "info");
            /*
             ******************Algorithm******************
             calculate npx, npxRatioSquare which change when map bounds change

             clear the result image data array

             foreach source
             calculate the per unit value of source voltage
             get the source location in pixels
             foreach canvaspixel
             calcualate pixel intensity according to the formula and add it to result image data array

             end
             end

             foreach result image data array pixel
             update maximum intensity value
             update minimum intensity value
             end

             calculate normalisation factor for result image data array

             multiply each pixel of result image data array with normalisation factor to get the hue of the pixel

             assign each pixel the hue obtained from normalised image data array
             */

            //clear and initialize
            canvasData = [];
            for (var iter = 0; iter < xp * yp; iter++) {
                canvasData[iter] = 0;
            }
            normalisedCanvasData = [];

            //For each source
            //var xpsource; var ypsource;
            for (var i = 0; i < sources.length; i++) {
                //var vsource = sources[i][2];
                vsource = sources[i][2];
                [xpsource, ypsource] = LatLongToPixelCoordinates(sources[i][0], sources[i][1]);
                for (var xpdest = 0; xpdest < xp; xpdest++) {
                    for (var ypdest = 0; ypdest < yp; ypdest++) {
                        //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
                        xpx = xpdest - xpsource;
                        ypx = ypdest - ypsource;
                        canvasData[(xpdest + ypdest * xp)] += vsource * Math.exp(-alpha * npx * Math.sqrt(xpx * xpx + npxRatioSquare * ypx * ypx));
                    } //y iterator
                } //x iterator
            } //source iterator

            //Find max and min voltage value in canvasData
            minVal = 1000;
            maxVal = 0;
            for (var xpdest = 0; xpdest < xp; xpdest++) {
                for (var ypdest = 0; ypdest < yp; ypdest++) {
                    //xpdest = x axis iterator; ypdest = y axis iterator
                    var val = canvasData[(xpdest + ypdest * xp)];
                    if (val < minVal) {
                        minVal = val;
                    } else if (val > maxVal) {
                        maxVal = val;
                    }
                } //y iterator
            } //x iterator

            //Do Normalisation
            //normalisedValue = hueDiff * (1 - value/(maxval-minval));
            //normalisedValue = hueDiff * (1 - value/(valDiff)); where valDiff = maxval-minval;
            valDiff = maxVal - minVal;
            for (var xpdest = 0; xpdest < xp; xpdest++) {
                for (var ypdest = 0; ypdest < yp; ypdest++) {
                    //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
                    //normalisedCanvasData[xpdest,ypdest] = hueDiff * (1 - canvasData[xpdest,ypdest]/(valDiff));//Use this for hue version
                    normalisedCanvasData[(xpdest + ypdest * xp)] = hueDiff * ((canvasData[(xpdest + ypdest * xp)] - minVal) / (valDiff));//Use this for RGB version
                } //y iterator
            } //x iterator
            //canvas putImageData reference - http://www.w3schools.com/tags/canvas_putimagedata.asp
            //canvas createImageData reference - http://www.w3schools.com/tags/canvas_createimagedata.asp

            //Clear Canvas Data
            canvasData = [];

            imageData = ctx.getImageData(0, 0, xp, yp);//imageData context.getImageData(x,y,width,height);

            for (var xpdest = 0; xpdest < xp; xpdest++) {
                for (var ypdest = 0; ypdest < yp; ypdest++) {
                    //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
                    hue = maxHue - normalisedCanvasData[(xpdest + ypdest * xp)];
                    [imageData.data[(ypdest * xp + xpdest) * 4], imageData.data[(ypdest * xp + xpdest) * 4 + 1], imageData.data[(ypdest * xp + xpdest) * 4 + 2]] = hsvToRgb(hue, 1, 1);
                    imageData.data[(ypdest * xp + xpdest) * 4 + 3] = transparency;
                } //y iterator
            } //x iterator

            //Clear normalisedCanvasData
            normalisedCanvasData = [];

            ctx.putImageData(imageData, 0, 0);

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;//LINE WIDTH IN PIXELS
            //ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            for (var i = 0; i < sources.length; i++) {
                [xpsource, ypsource] = LatLongToPixelCoordinates(sources[i][0], sources[i][1]);
                ctx.beginPath(); // Start the path
                ctx.arc(xpsource, ypsource, 2, 0, Math.PI * 2, false); //void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
                ctx.closePath(); // Close the path
                ctx.stroke();
                ctx.fill(); // Fill the path
            }
        }

        function domReady() {
            //initialize canvas variables
            c = document.getElementById("myCanvas");
            computeCanvasParams();

            //canvas resize listener
            new ResizeSensor(c, computeCanvasParams);

            addSourcesToTable();
        }

        function mapSourceLoaded() {
            //initialize map
            myCenter = new google.maps.LatLng(22.532853026644325, 78.16772421874998);
            var mapProp = {
                center: myCenter,
                zoom: 6,
                mapTypeId: google.maps.MapTypeId.ROADMAP
            };

            map = new google.maps.Map(document.getElementById("google_map"), mapProp);

            //set marker
            var marker = new google.maps.Marker({
                position: myCenter,
                animation: google.maps.Animation.BOUNCE
            });

            marker.setMap(map);

            //add listener for map bounds being changed
            //google.maps.event.addListener(map,'bounds_changed', onMapStateChanged); // end of listener callbck
            google.maps.event.addListener(map, 'idle', onMapStateChanged);

            getAlpha();
            getTrans();
        }

        /*Alpha getter*/
        function getAlpha() {
            document.getElementById("alphaTextControl").value = "" + alpha;
            document.getElementById("alphaTextControl").style.color = 'blue';
        }

        /*Alpha setter*/
        function setAlpha() {
            var num = Number(document.getElementById("alphaTextControl").value);
            if (!isNaN(num)) {
                document.getElementById("alphaTextControl").style.color = 'black';
                alpha = num;
                WriteLineConsole("Set the canvas Alpha to " + num, "success");
                onMapStateChanged();
            } else {
                WriteLineConsole("Please enter numeric Input ", "error");
                document.getElementById("alphaTextControl").style.color = 'red';
            }

        }

        /*Transperency getter*/
        function getTrans() {
            document.getElementById("transControl").value = "" + transparency;
            document.getElementById("transControl").style.color = 'blue';
        }

        /*Transperency setter*/
        function setTrans() {
            var num = Number(document.getElementById("transControl").value);
            if (!isNaN(num)) {
                document.getElementById("transControl").style.color = 'black';
                WriteLineConsole("Set the canvas Transperency to " + num, "success");
                transparency = num;
                onMapStateChanged();
            } else {
                WriteLineConsole("Please enter numeric Input ", "error");
                document.getElementById("transControl").style.color = 'red';
            }

        }

        /*
         * HSV to RGB color conversion
         *
         * H runs from 0 to 360 degrees
         * S and V run from 0 to 1
         *
         * Ported from the excellent java algorithm by Eugene Vishnevsky at:
         * http://www.cs.rit.edu/~ncs/color/t_convert.html
         */
        function hsvToRgb(h, s, v) {
            var r, g, b;
            var i;
            var f, p, q, t;

            // Make sure our arguments stay in-range
            h = Math.max(0, Math.min(360, h));
            ////s = Math.max(0, Math.min(1, s));
            ////v = Math.max(0, Math.min(1, v));

            /****if(s == 0) {
					// Achromatic (grey)
					r = g = b = v;
					return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
					}****/

            h /= 60; // sector 0 to 5
            i = Math.floor(h);
            f = h - i; // factorial part of h
            p = v * (1 - s);
            q = v * (1 - s * f);
            t = v * (1 - s * (1 - f));

            switch (i) {
                case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;

                case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;

                case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;

                case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;

                case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;

                default: // case 5:
                    r = v;
                    g = p;
                    b = q;
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
    </script>
</head>
<body>
<div id="wrapper">
    <div id="google_map" style="width:100%;height:100%;"></div>
    <canvas id="myCanvas" style="border:3px solid #0000d3;">Your browser does not support the HTML5 canvas tag.</canvas>
</div>
<div id="controlInputs" style="margin:10px 5px 5px 10px;"><!--top right bottom left-->

    <h3 onclick="showHide(this,'> Alpha','^ Alpha')" style="display:inline"> > Alpha</h3>
    <div class="hidingClass" style="display:none; margin:5px 0px;">
        <input id="alphaTextControl" style="width:50px;" type="text" onkeypress="return isNumberKey()"/>
        <button onclick="getAlpha()" style="margin:0px 10px;">GetAlpha</button>
        <button onclick="setAlpha()">SetAlpha</button>
    </div>

    <br>

    <h3 onclick="showHide(this,'> Transperency','^ Transperency')" style="display:inline"> > Transperency</h3>
    <div class="hidingClass" style="display:none; margin:5px 0px;">
        <input id="transControl" style="width:50px;" type="text" onkeypress="return isNumberKey()"/>
        <!-- <input id="alphaTextControl" style="width:50px;" type="text" onkeydown="return numericListener()" /> -->
        <button onclick="getTrans()" style="margin:0px 10px;">GetTransperency</button>
        <button onclick="setTrans()">SetTransperency</button>
    </div>

    <br>

    <h3 onclick="showHide(this,'> Voltage Points','^ Voltage Points')" style="display:inline"> > Voltage Points</h3>
    <div class="hidingClass" style="display:none; margin:5px 0px;">
        <table>
            <thead>
            <tr>
                <td>SNo</td>
                <td>Name</td>
                <td>Latitude</td>
                <td>Longitude</td>
                <td>Value</td>
            </tr>
            </thead>
            <tbody id="mSourceTable"></tbody>
        </table>
        <button onclick="clearTable()">Clear Table</button>
        <button onclick="addSourcesToTable()">Populate Table</button>
    </div>

    <br>

    <h3 onclick="showHide(this,'> Console','^ Console')" style="display:inline"> > Console</h3><br>

    <div class="hidingClass" style="display:none; margin:5px 0px;">
        <div id="console" style="border: 1px solid black;width: 95%;height: 400px;overflow: scroll;">
        </div>
        <button onclick="clearConsole()">ClearConsole</button>
    </div>
</div>
<!-- Do stuff after a timeout clearing previous timeouts - http://stackoverflow.com/questions/9252493/google-maps-event-addlistenermap-idle-function-is-it-possible-to-specif -->
<!-- A complete interactive experience of google maps API- http://gmaps-samples-v3.googlecode.com/svn/trunk/map_events/map_events.html -->
</body>
</html>
