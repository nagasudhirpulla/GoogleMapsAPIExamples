<html>
	<head>
		<style>
			#wrapper { position: relative;width:900px;height:500px; }
			#over_map { position: absolute; top: 80px;right: 0;width: 200px;height: 100px;border: 3px solid #73AD21; z-index: 99;color:red; }
			#myCanvas { position: absolute; top: 0px;left: 0; z-index: 98;width:100%;height:100%;pointer-events:none; }
		</style>
		<script src="http://maps.googleapis.com/maps/api/js"></script>
		<!--Element Resize Listener Libraries - http://marcj.github.io/css-element-queries/-->
		<script src="ResizeSensor.js"></script>
		<script src="ElementQueries.js"></script>
		<script>
			//TODO APPEND BEFORE FOR CONSOLE OUTPUT - DONE
			//TODO TIMER FOR MAP REFRESH - DONE BY USING idle listener event of maps API
			//TODO DISPLAY SOURCES LATITUDES, LONGITUDES SERVICE NAMES POINT IDS VALUES IN A TABLE
			//TODO CREATE AN EVAL BOX FOR DEBUGGING
			
			<!--Map Setting Script-->
			var myCenter=new google.maps.LatLng(22.532853026644325,78.16772421874998); var marker; var map;
			var ctx;var c;
			var xp; var yp;
			var latx1; var latx2; var longy1; var longy2;
			var lat_width; var long_hgt;
			var npx; var npy; var npxRatioSquare;
			var sources = [[22.532853026644325,78.16772421874998,1.5], [21.2016592,81.1051448,1.1]];
			var alpha = 1.5;
			var transparency = 80;//between 0 - 255
			var canvasData = [];var normalisedCanvasData = [];var imageData = [];
			var minVal; var maxVal; var valDiff;
			var maxHue = 120; var minHue = 0; var hueDiff = maxHue - minHue; //Lets go for red color for now
			var xpsource; var ypsource;var vsource;
			var mConsole;
			var mSourceTable;
			
			//Utility Functions
			function doStyling(style, tag){
					style.display = 'block';
					style.fontSize = '0.9em';
					style.fontFamily = "Courier New";
					if(tag == 'error'){
						style.color = 'red';
					}else if(tag == 'warning'){
						style.color = '#FF8C00';
					} else if(tag == 'info'){
						style.color = 'blue';
					} else if(tag == 'success'){
						style.color = 'blue';
					}
			}
			
			//Utility Functions
			function WritelineConsole(str, tag){
				var currentdate = new Date();
				var para = document.createElement("span");
				var n = currentdate.getDate() + "/"
                + (currentdate.getMonth()+1)  + "/" 
                + currentdate.getFullYear() + " @ "  
                + currentdate.getHours() + ":"  
                + currentdate.getMinutes() + ":" 
                + currentdate.getSeconds()+" - ";
				var node = document.createTextNode(n+str);
				para.appendChild(node);
				//mConsole.appendChild(para);
				mConsole.insertBefore(para, mConsole.firstChild);
				doStyling(para.style,tag);				
			}
			
			//Utility Functions
			function clearConsole(str, tag){				
				mConsole.innerHTML = "";
			}
			
			//Utility Functions
			function addRow() {
				//var rowCount = mSourceTable.rows.length;
				//var colCount = table.rows[0].cells.length;
				var row = mSourceTable.insertRow(0);//if row to inserted at last then insert at rowCount
				for (var i = 0; i < arguments.length; i++) {
					//alert(arguments[i]);
					var newCell = row.insertCell(0);
					var t = document.createTextNode(arguments[i]);
					var s = document.createElement("span");
					s.appendChild(t);
					newCell.appendChild(s);
				}
				//row inserted in to the table
			}
			
			//Utility Functions
			//Numeric text input listener
			//http://stackoverflow.com/questions/33251052/allow-only-numbers-and-ctrla-ctrlv-ctrlc-to-a-textbox
			function numericListener(e) {
				// Allow: backspace, delete, tab, escape, enter and .
				if ([46, 8, 9, 27, 13, 110, 190].indexOf(e.keyCode) !== -1 ||
				// Allow: Ctrl+A
				(e.keyCode == 65 && e.ctrlKey === true) ||
				// Allow: Ctrl+C
				(e.keyCode == 67 && e.ctrlKey === true) ||
				// Allow: Ctrl+X
				(e.keyCode == 88 && e.ctrlKey === true) ||
				// Allow: home, end, left, right
				(e.keyCode >= 35 && e.keyCode <= 39)) {
					// let it happen, don't do anything
					return;
				}
				// Ensure that it is a number and stop the keypress
				if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
					e.preventDefault();
				}
			}
			
			//Utility Functions
			function showHide(el, txt1, txt2) {
				//Toggle Display button for the table
				var div = findSibling(el, "hidingClass");
				if (div.style.display !== "none") {
					div.style.display = "none";
					el.textContent = txt1;
					} else {
					div.style.display = "block";
					el.textContent = txt2;
				}
			}
			
			//Utility Functions
			function findSibling(el, cls) {
				while (!el.classList.contains(cls)) {
					el = el.nextElementSibling;
				}
				return el;
			}
			
			//Utility Functions
			function isNumberKey(evt) {
				//charcodes info http://www.cambiaresearch.com/articles/15/javascript-key-codes
				evt = (evt) ? evt : window.event;
				var charCode = (evt.which) ? evt.which : evt.keyCode;
				if (charCode < 32 || (charCode > 47 && charCode < 58) || (charCode == 46)) {
					return true;
				}
				return false;
			}
			
			/*LatLong to pixel conversion function*/
			function LatLongToPixelCoordinates(latx, longy){
				return [parseInt((xp/lat_width)*(longy - latx1)), parseInt((yp/long_hgt )*(longy2-latx))];
				//return [parseInt((xp/lat_width)*(latx - latx1),10), parseInt((yp/long_hgt )*(longy-longy1),10)];
			}
			
			/*Get all Voltage sources locations and p.u values as a [nx3] array */
			function getVoltagePoints(){
				// [[1,2],[3,4]];//items[0][0] = 1
				return sources;
			}
			
			//Compute Canvas Parameters - Do this if canvas measurements change
			function computeCanvasParams(){
				//get Console and SourceTable objects
				mConsole = document.getElementById("console");
				mSourceTable = document.getElementById("sourcesTable");
				
				//Canvas initialization
				ctx = c.getContext("2d");
				ctx.strokeStyle='blue';
				ctx.fillStyle = 'rgba(0, 0, 0, 0)';
				//ctx.fillStyle = "blue";
				//ctx.fillStyle = "rgb(255, 0, 0)";
				//Get the Width and LengtSTUh of canvas				
				xp = getComputedStyle(c,null).getPropertyValue('width');
				xp = xp.substring(0, xp.length-2);
				ctx.canvas.width = xp;
				yp = getComputedStyle(c,null).getPropertyValue('height');
				yp = yp.substring(0, yp.length-2);
				ctx.canvas.height = yp;
				WritelineConsole("*********************************", "warning");
				WritelineConsole("Writing DIV dimensions in pixels");
				WritelineConsole("Width of div is "+xp, "info");
				WritelineConsole("Height of div is "+yp, "info");
				//WritelineConsole("*********************************", "info");
				for(var i=0;i<sources.length;i++){
					//addRow(i+1, "name", sources[i][0], sources[i][0], sources[i][0]);
				}
			}
			
			//After the canvas bounds can be measured and when canvas bounds are changed
			function measureBounds() 
			{
				//get mapbounds
				var ne = map.getBounds().getNorthEast();//topRight
				var sw = map.getBounds().getSouthWest();//bottomLeft
				latx1 = sw.lng();
				latx2 = ne.lng();
				longy1 = sw.lat();
				longy2 = ne.lat();
				//View Port Width in degrees
				lat_width =  latx2 - latx1;
				long_hgt = longy2 - longy1;
				//No of degrees per pixel on X axis
				npx = lat_width/xp;
				//No of degrees per pixel on Y axis
				npy  = long_hgt/yp;
				//npxRatio = npy/npx;
				npxRatioSquare = (npy*npy)/(npx*npx);
				sources = getVoltagePoints();
				WritelineConsole("*********************************", "warning");
				WritelineConsole("Writing DIV dimensions in degrees");
				WritelineConsole("Width of div is "+lat_width, "info");
				WritelineConsole("Height of div is "+long_hgt, "info");
				WritelineConsole("Longitude bounds are "+latx1 + " and "+latx2, "info");
				WritelineConsole("Latitude bounds are "+longy1 + " and "+longy1, "info");
				WritelineConsole("degrees / pixel on X axis is "+npx, "info");
				WritelineConsole("degrees / pixel on Y axis is "+npy, "info");
				
				//WritelineConsole("*********************************", "info");
				/*
					******************Algorithm******************
					calculate npx, npxRatioSquare which change when map bounds change
					
					clear the result image data array
					
					foreach source
					calculate the per unit value of source voltage
					get the source location in pixels
					foreach canvaspixel
					calcualate pixel intensity according to the formula and add it to result image data array
					
					end
					end
					
					foreach result image data array pixel
					update maximum intensity value
					update minimum intensity value
					end
					
					calculate normalisation factor for result image data array
					
					multiply each pixel of result image data array with normalisation factor to get the hue of the pixel
					
					assign each pixel the hue obtained from normalised image data array
				*/
				
				//clear and initialize
				canvasData = [];
				for(var iter=0;iter<xp*yp;iter++){
					canvasData[iter] = 0;
				}
				normalisedCanvasData = [];				
				//For each source
				//var xpsource; var ypsource;
				for(var i=0;i<sources.length;i++){
					//var vsource = sources[i][2];					
					vsource = sources[i][2];					
					[xpsource, ypsource] = LatLongToPixelCoordinates(sources[i][0], sources[i][1]);
					for(var xpdest=0;xpdest<xp;xpdest++){
						for(var ypdest=0;ypdest<yp;ypdest++){
							//i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
							xpx = xpdest - xpsource;
							ypx = ypdest - ypsource;
							canvasData[(xpdest+ypdest*xp)] += vsource*Math.exp(-alpha*npx*Math.sqrt(xpx*xpx+npxRatioSquare*ypx*ypx));
						} //y iterator						
					} //x iterator
				} //source iterator
				
				//Find max and min voltage value in canvasData
				minVal = 1000; maxVal = 0;
				for(var xpdest=0;xpdest<xp;xpdest++){
					for(var ypdest=0;ypdest<yp;ypdest++){
						//xpdest = x axis iterator; ypdest = y axis iterator
						var val =  canvasData[(xpdest+ypdest*xp)];
						if(val < minVal){
							minVal = val;
							} else if(val > maxVal){
							maxVal = val;
						}
					} //y iterator						
				} //x iterator
				
				//Do Normalisation
				//normalisedValue = hueDiff * (1 - value/(maxval-minval));
				//normalisedValue = hueDiff * (1 - value/(valDiff)); where valDiff = maxval-minval;
				valDiff = maxVal-minVal;
				for(var xpdest=0; xpdest < xp; xpdest++){
					for(var ypdest=0; ypdest < yp; ypdest++){
						//i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
						//normalisedCanvasData[xpdest,ypdest] = hueDiff * (1 - canvasData[xpdest,ypdest]/(valDiff));//Use this for hue version
						normalisedCanvasData[(xpdest + ypdest*xp)] = hueDiff * ((canvasData[(xpdest + ypdest*xp)] - minVal)/(valDiff));//Use this for RGB version
					} //y iterator						
				} //x iterator
				//canvas putImageData reference - http://www.w3schools.com/tags/canvas_putimagedata.asp
				//canvas createImageData reference - http://www.w3schools.com/tags/canvas_createimagedata.asp
				
				imageData = ctx.getImageData(0, 0, xp, yp);//imageData context.getImageData(x,y,width,height);
				
				for(var xpdest = 0;xpdest < xp; xpdest++){
					for(var ypdest = 0;ypdest < yp; ypdest++){
						//i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
						hue = maxHue - normalisedCanvasData[(xpdest + ypdest*xp)];
						[imageData.data[(ypdest*xp + xpdest)*4], imageData.data[(ypdest*xp + xpdest)*4 + 1], imageData.data[(ypdest*xp + xpdest)*4 + 2]] = hsvToRgb(hue, 1, 1);
						imageData.data[(ypdest*xp + xpdest)*4 + 3] = transparency;
					} //y iterator						
				} //x iterator
				
				ctx.putImageData(imageData, 0, 0);
				
				ctx.strokeStyle='black';
				ctx.lineWidth=1;//LINE WIDTH IN PIXELS
				//ctx.fillStyle = 'rgba(0, 0, 0, 0)';
				for(var i=0;i<sources.length;i++){
					[xpsource, ypsource] = LatLongToPixelCoordinates(sources[i][0], sources[i][1]);
					ctx.beginPath(); // Start the path
					ctx.arc(xpsource, ypsource, 2, 0, Math.PI*2, false); //void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
					ctx.closePath(); // Close the path
					ctx.stroke();
					//ctx.fill(); // Fill the path
				}
			}
			
			function initialize()
			{
			  	//initialize canvas varibles
			  	c = document.getElementById("myCanvas");
				computeCanvasParams();
				
				//canvas resize listener
				new ResizeSensor(c, computeCanvasParams);
				
				//initialize map
				var mapProp = {
					center:myCenter,
					zoom:6,
					mapTypeId:google.maps.MapTypeId.ROADMAP
				};
				
				map=new google.maps.Map(document.getElementById("google_map"),mapProp);
				
				//set marker
				var marker=new google.maps.Marker({
					position:myCenter,
					animation:google.maps.Animation.BOUNCE
				});
				
				marker.setMap(map);
				
				//add listener for map bounds being changed
				//google.maps.event.addListener(map,'bounds_changed', measureBounds); // end of listener callbck
				google.maps.event.addListener(map,'idle', measureBounds);
				getAlpha();
				getTrans();
			}
			
			//DOM load initialization function
			google.maps.event.addDomListener(window, 'load', initialize);
						
			/*Alpha getter*/
			function getAlpha() {
				document.getElementById("alphaTextControl").value = "" + alpha;
				document.getElementById("alphaTextControl").style.color = 'blue';
			}	
			
			/*Alpha setter*/
			function setAlpha() {
				var num = Number(document.getElementById("alphaTextControl").value);
				if(!isNaN(num)){
					document.getElementById("alphaTextControl").style.color = 'black';
					alpha = num;
					WritelineConsole("Set the canvas Alpha to " + num, "success");
					measureBounds();
					}else{
					WritelineConsole("Please enter numeric Input ", "error");
					document.getElementById("alphaTextControl").style.color = 'red';
				}
			
			}
			
			/*Transperency getter*/
			function getTrans() {
				document.getElementById("transControl").value = "" + transparency;
				document.getElementById("transControl").style.color = 'blue';
			}
			
			/*Transperency setter*/
			function setTrans() {
				var num = Number(document.getElementById("transControl").value);
				if(!isNaN(num)){
					document.getElementById("transControl").style.color = 'black';
					WritelineConsole("Set the canvas Transperency to " + num, "success");
					transparency = num;
					measureBounds();
					}else{
					WritelineConsole("Please enter numeric Input ", "error");
					document.getElementById("transControl").style.color = 'red';
				}
				
			}			
			
			/*
				* HSV to RGB color conversion
				*
				* H runs from 0 to 360 degrees
				* S and V run from 0 to 1
				* 
				* Ported from the excellent java algorithm by Eugene Vishnevsky at:
				* http://www.cs.rit.edu/~ncs/color/t_convert.html
			*/
			function hsvToRgb(h, s, v) {
				var r, g, b;
				var i;
				var f, p, q, t;
				
				// Make sure our arguments stay in-range
				h = Math.max(0, Math.min(360, h));
				////s = Math.max(0, Math.min(1, s));
				////v = Math.max(0, Math.min(1, v));
				
				/****if(s == 0) {
					// Achromatic (grey)
					r = g = b = v;
					return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
					}****/
					
					h /= 60; // sector 0 to 5
					i = Math.floor(h);
					f = h - i; // factorial part of h
					p = v * (1 - s);
					q = v * (1 - s * f);
					t = v * (1 - s * (1 - f));
					
					switch(i) {
						case 0:
						r = v;
						g = t;
						b = p;
						break;
						
						case 1:
						r = q;
						g = v;
						b = p;
						break;
						
						case 2:
						r = p;
						g = v;
						b = t;
						break;
						
						case 3:
						r = p;
						g = q;
						b = v;
						break;
						
						case 4:
						r = t;
						g = p;
						b = v;
						break;
						
						default: // case 5:
						r = v;
						g = p;
						b = q;
					}				
					return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
				}
			</script>
		</head>
		<body>
			<div id="wrapper">
				<div id="google_map" style="width:100%;height:100%;"></div>
				<canvas id="myCanvas" style="border:3px solid #0000d3;">Your browser does not support the HTML5 canvas tag.</canvas>
			</div>
			<div id="controlInputs" style="margin:10px 5px 5px 10px;"><!--top right bottom left-->
				<h3>Alpha</h3>
				<input id="alphaTextControl" style="width:50px;" type="text" onkeypress="return isNumberKey()" />
				<button onclick="getAlpha()" style="margin:0px 10px;">GetAlpha</button><button onclick="setAlpha()">SetAlpha</button>
				<h3>Transperency</h3>
				<input id="transControl" style="width:50px;" type="text" onkeypress="return isNumberKey()" />
				<!-- <input id="alphaTextControl" style="width:50px;" type="text" onkeydown="return numericListener()" /> -->
				<button onclick="getTrans()" style="margin:0px 10px;">GetTransperency</button><button onclick="setTrans()">SetTransperency</button>
				<table style="border: 1px solid black;border-collapse: collapse;"><thead><tr><td>SNo</td><td>Name</td><td>Latitude</td><td>Longitude</td><td>Value</td></tr></thead><tbody id="mSourceTable"></tbody></table>
				<br><br><h3 onclick="showHide(this,'> Console','^ Console')" style="display:inline"> > Console</h3><br>
				<div id="console" class="hidingClass" style="display:none;border: 1px solid black;width: 95%;height: 400px;overflow: scroll;">
				</div>
				<br><button onclick="clearConsole()">ClearConsole</button>
			</div>
			<!-- Do stuff after a timeout clearing previous timeouts - http://stackoverflow.com/questions/9252493/google-maps-event-addlistenermap-idle-function-is-it-possible-to-specif -->
			<!-- A complete interactive experience of google maps API- http://gmaps-samples-v3.googlecode.com/svn/trunk/map_events/map_events.html -->
		</body>
	</html>	
