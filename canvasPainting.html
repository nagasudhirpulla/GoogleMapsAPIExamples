<html>
	<head>
		<style>
			#wrapper { position: relative;width:900px;height:500px; }
			#over_map { position: absolute; top: 80px;right: 0;width: 200px;height: 100px;border: 3px solid #73AD21; z-index: 99;color:red; }
			#myCanvas { position: absolute; top: 0px;left: 0; z-index: 98;width:100%;height:100%;pointer-events:none; }
		</style>
		<script src="http://maps.googleapis.com/maps/api/js"></script>
		<!--Element Resize Listener Libraries - http://marcj.github.io/css-element-queries/-->
		<script src="ResizeSensor.js"></script>
		<script src="ElementQueries.js"></script>
		<script>
			<!--Map Setting Script-->
			var myCenter=new google.maps.LatLng(22.532853026644325,78.16772421874998); var marker; var map;
			var ctx;var c;
			var xp; var yp;
			var latx1; var latx2; var longy1; var longy2;
			var lat_width; var long_hgt;
			var npx; var npy; var npxRatioSquare;
			var sources = [[22.532853026644325,78.16772421874998,1.5], [21.2016592,81.1051448,1.1]];
			var alpha = 1.5;
			var canvasData = [];var normalisedCanvasData = [];var imageData = [];
			var minVal; var maxVal; var valDiff;
			var maxHue = 120; var minHue = 0; var hueDiff = maxHue - minHue; //Lets go for red color for now
			var xpsource; var ypsource;var vsource;
			/*LatLong to pixel conversion function*/
			function LatLongToPixelCoordinates(latx, longy){
				return [parseInt((xp/lat_width)*(longy - latx1)), parseInt((yp/long_hgt )*(longy2-latx))];
				//return [parseInt((xp/lat_width)*(latx - latx1),10), parseInt((yp/long_hgt )*(longy-longy1),10)];
			}
			
			/*Get all Voltage sources locations and p.u values as a [nx3] array */
			function getVoltagePoints(){
				// [[1,2],[3,4]];//items[0][0] = 1
				return sources;
			}
			
			//Compute Canvas Parameters - Do this if canvas measurements change
			function computeCanvasParams(){
				//Canvas initialization
				ctx = c.getContext("2d");
				ctx.strokeStyle='blue';
				ctx.fillStyle = 'rgba(0, 0, 0, 0)';
				//ctx.fillStyle = "blue";
				//ctx.fillStyle = "rgb(255, 0, 0)";
				//Get the Width and LengtSTUh of canvas				
				xp = getComputedStyle(c,null).getPropertyValue('width');
				xp = xp.substring(0, xp.length-2);
				ctx.canvas.width = xp;
				yp = getComputedStyle(c,null).getPropertyValue('height');
				yp = yp.substring(0, yp.length-2);
				ctx.canvas.height = yp;
			}
			
			//After the canvas bounds can be measured and when canvas bounds are changed
			function measureBounds() 
			{
				//get mapbounds
				var ne = map.getBounds().getNorthEast();//topRight
				var sw = map.getBounds().getSouthWest();//bottomLeft
				latx1 = sw.lng();
				latx2 = ne.lng();
				longy1 = sw.lat();
				longy2 = ne.lat();
				//View Port Width in degrees
				lat_width =  latx2 - latx1;
				long_hgt = longy2 - longy1;
				//No of degrees per pixel on X axis
				npx = lat_width/xp;
				//No of degrees per pixel on Y axis
				npy  = long_hgt/yp;
				//npxRatio = npy/npx;
				npxRatioSquare = (npy*npy)/(npx*npx);
				sources = getVoltagePoints();
				/*
					******************Algorithm******************
					calculate npx, npxRatioSquare which change when map bounds change
					
					clear the result image data array
					
					foreach source
					calculate the per unit value of source voltage
					get the source location in pixels
						foreach canvaspixel
							calcualate pixel intensity according to the formula and add it to result image data array
					
						end
					end
					
					foreach result image data array pixel
						update maximum intensity value
						update minimum intensity value
					end
					
					calculate normalisation factor for result image data array
					
					multiply each pixel of result image data array with normalisation factor to get the hue of the pixel
					
					assign each pixel the hue obtained from normalised image data array
				*/
				
				//clear and initialize
				canvasData = [];
				for(var iter=0;iter<xp*yp;iter++){
					canvasData[iter] = 0;
				}
				normalisedCanvasData = [];				
				//For each source
				//var xpsource; var ypsource;
				for(var i=0;i<sources.length;i++){
					//var vsource = sources[i][2];					
					vsource = sources[i][2];					
					[xpsource, ypsource] = LatLongToPixelCoordinates(sources[i][0], sources[i][1]);
					for(var xpdest=0;xpdest<xp;xpdest++){
						for(var ypdest=0;ypdest<yp;ypdest++){
							//i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
							xpx = xpdest - xpsource;
							ypx = ypdest - ypsource;
							canvasData[(xpdest+ypdest*xp)] += vsource*Math.exp(-alpha*npx*Math.sqrt(xpx*xpx+npxRatioSquare*ypx*ypx));
						} //y iterator						
					} //x iterator
				} //source iterator
				
				//Find max and min voltage value in canvasData
				minVal = 1000; maxVal = 0;
				for(var xpdest=0;xpdest<xp;xpdest++){
					for(var ypdest=0;ypdest<yp;ypdest++){
						//xpdest = x axis iterator; ypdest = y axis iterator
						var val =  canvasData[(xpdest+ypdest*xp)];
						if(val < minVal){
							minVal = val;
							} else if(val > maxVal){
							maxVal = val;
						}
					} //y iterator						
				} //x iterator
				
				//Do Normalisation
				//normalisedValue = hueDiff * (1 - value/(maxval-minval));
				//normalisedValue = hueDiff * (1 - value/(valDiff)); where valDiff = maxval-minval;
				valDiff = maxVal-minVal;
				for(var xpdest=0; xpdest < xp; xpdest++){
					for(var ypdest=0; ypdest < yp; ypdest++){
						//i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
						//normalisedCanvasData[xpdest,ypdest] = hueDiff * (1 - canvasData[xpdest,ypdest]/(valDiff));//Use this for hue version
						normalisedCanvasData[(xpdest + ypdest*xp)] = hueDiff * ((canvasData[(xpdest + ypdest*xp)] - minVal)/(valDiff));//Use this for RGB version
					} //y iterator						
				} //x iterator
				//canvas putImageData reference - http://www.w3schools.com/tags/canvas_putimagedata.asp
				//canvas createImageData reference - http://www.w3schools.com/tags/canvas_createimagedata.asp
				
				imageData = ctx.getImageData(0, 0, xp, yp);//imageData context.getImageData(x,y,width,height);
				
				for(var xpdest = 0;xpdest < xp; xpdest++){
					for(var ypdest = 0;ypdest < yp; ypdest++){
						//i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
						hue = maxHue - normalisedCanvasData[(xpdest + ypdest*xp)];
						[imageData.data[(ypdest*xp + xpdest)*4], imageData.data[(ypdest*xp + xpdest)*4 + 1], imageData.data[(ypdest*xp + xpdest)*4 + 2]] = hsvToRgb(hue, 1, 1);
						imageData.data[(ypdest*xp + xpdest)*4 + 3] = 80;
					} //y iterator						
				} //x iterator
				
				ctx.putImageData(imageData, 0, 0);
				
				ctx.strokeStyle='black';
				ctx.lineWidth=1;//LINE WIDTH IN PIXELS
				//ctx.fillStyle = 'rgba(0, 0, 0, 0)';
				for(var i=0;i<sources.length;i++){
					[xpsource, ypsource] = LatLongToPixelCoordinates(sources[i][0], sources[i][1]);
					ctx.beginPath(); // Start the path
					ctx.arc(xpsource, ypsource, 2, 0, Math.PI*2, false); // Draw a circle - void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
					ctx.closePath(); // Close the path
					ctx.stroke();
					//ctx.fill(); // Fill the path
				}
			}
			function initialize()
			{
			  	//initialize canvas varibles
			  	c = document.getElementById("myCanvas");
				computeCanvasParams();
				
				//canvas resize listener
				new ResizeSensor(c, computeCanvasParams);
				
				//initialize map
				var mapProp = {
					center:myCenter,
					zoom:6,
					mapTypeId:google.maps.MapTypeId.ROADMAP
				};
				
				map=new google.maps.Map(document.getElementById("google_map"),mapProp);
				
				//set marker
				var marker=new google.maps.Marker({
					position:myCenter,
					animation:google.maps.Animation.BOUNCE
				});
				
				marker.setMap(map);
				
				//add listener for map bounds being changed
				google.maps.event.addListener(map,'bounds_changed', measureBounds); // end of listener callbck
				getAlpha();
			}
			
			//DOM load initialization function
			google.maps.event.addDomListener(window, 'load', initialize);
			
			/*Alpha setter*/
			function setAlpha() {
				var num = Number(document.getElementById("alphaTextControl").value);
				if(!isNaN(num)){
					document.getElementById("alphaTextControl").style.color = 'black';
					alpha = num;
					measureBounds();
				}else{
					document.getElementById("alphaTextControl").style.color = 'red';
				}
				
			}
			/*Alpha getter*/
			function getAlpha() {
				document.getElementById("alphaTextControl").value = "" + alpha;
				document.getElementById("alphaTextControl").style.color = 'blue';
			}
			/*Numeric text input listener*/
			function numericListener(e) {
			        // Allow: backspace, delete, tab, escape, enter and .
			        if ([46, 8, 9, 27, 13, 110, 190].indexOf(e.keyCode) !== -1 ||
			             // Allow: Ctrl+A
			            (e.keyCode == 65 && e.ctrlKey === true) ||
			             // Allow: Ctrl+C
			            (e.keyCode == 67 && e.ctrlKey === true) ||
			             // Allow: Ctrl+X
			            (e.keyCode == 88 && e.ctrlKey === true) ||
			             // Allow: home, end, left, right
			            (e.keyCode >= 35 && e.keyCode <= 39)) {
			                 // let it happen, don't do anything
			                 return;
			            }
			        // Ensure that it is a number and stop the keypress
			        if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
			            e.preventDefault();
			        }
			    }
			  
			/*
			* HSV to RGB color conversion
			*
			* H runs from 0 to 360 degrees
			* S and V run from 0 to 1
			* 
			* Ported from the excellent java algorithm by Eugene Vishnevsky at:
			* http://www.cs.rit.edu/~ncs/color/t_convert.html
			*/
			function hsvToRgb(h, s, v) {
				var r, g, b;
				var i;
				var f, p, q, t;
				
				// Make sure our arguments stay in-range
				h = Math.max(0, Math.min(360, h));
				////s = Math.max(0, Math.min(1, s));
				////v = Math.max(0, Math.min(1, v));
				
				/****if(s == 0) {
					// Achromatic (grey)
					r = g = b = v;
					return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
				}****/
				
				h /= 60; // sector 0 to 5
				i = Math.floor(h);
				f = h - i; // factorial part of h
				p = v * (1 - s);
				q = v * (1 - s * f);
				t = v * (1 - s * (1 - f));
				
				switch(i) {
					case 0:
					r = v;
					g = t;
					b = p;
					break;
					
					case 1:
					r = q;
					g = v;
					b = p;
					break;
					
					case 2:
					r = p;
					g = v;
					b = t;
					break;
					
					case 3:
					r = p;
					g = q;
					b = v;
					break;
					
					case 4:
					r = t;
					g = p;
					b = v;
					break;
					
					default: // case 5:
					r = v;
					g = p;
					b = q;
				}
				
				return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
			}
		</script>		
	</head>
	<body>
		<div id="wrapper">
			<div id="google_map" style="width:100%;height:100%;"></div>
			<div id="over_map"><p>Iam over map</p></div>
			<canvas id="myCanvas" style="border:3px solid #0000d3;">Your browser does not support the HTML5 canvas tag.</canvas>
	 	</div>
	 	<div id="controlInputs" style="margin:10px 5px 5px 10px;"><!--top right bottom left-->
	 		<h3>Alpha</h3>
	 		<input id="alphaTextControl" style="width:50px;" type='text' onkeypress='numericListener(event)' />
	 		<button onclick="getAlpha()" style="margin:0px 10px;">GetAlpha</button><button onclick="setAlpha()">SetAlpha</button>
	 		<h3>Console</h3>
	 		<div id="console" style="border: 1px solid black;width: 600px;margin:0px 10px;height: 400px;overflow: scroll;">
	 		</div>
	 	</div>
	 	
	</body>
</html>
