<html>
<head>
    <style>
        #wrapper {
            position: relative;
            width: 1000px;
            height: 600px;
            border:2px solid #999999;
        }
        #over_map {
            position: absolute;
            top: 80px;
            right: 0;
            width: 200px;
            height: 100px;
            border: 3px solid #73AD21;
            z-index: 99;
            color: red;
        }
        #myCanvas {
            position: absolute;
            top: 0px;
            left: 0;
            z-index: 98;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .showHideButton {
            /*-moz-appearance:button; /!* Firefox *!/
            -webkit-appearance:button; /!* Safari and Chrome *!/
            appearance:button;*/
            border: 1px solid black;
            padding-left: 1px;
            padding-right: 1px;
            display: inline;
        }
    </style>
    <style>
        table {
            border-collapse: collapse;
        }
        table, td, th {
            border: 1px solid black;
        }
    </style>
    <!--Element Resize Listener Libraries - http://marcj.github.io/css-element-queries/-->
    <script src="ResizeSensor.js"></script>
    <script src="ElementQueries.js"></script>
    <!--script src="http://maps.googleapis.com/maps/api/js"></script-->
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
    <!--<script src="http://geoxml3.googlecode.com/svn/branches/polys/geoxml3.js"></script>-->
    <script src="http://geoxml3.googlecode.com/svn/trunk/ProjectedOverlay.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    <script>
        //TODO APPEND BEFORE FOR CONSOLE OUTPUT - DONE
        //TODO TIMER FOR MAP REFRESH - DONE BY USING idle listener event of maps API
        //TODO DISPLAY SOURCES LATITUDES, LONGITUDES SERVICE NAMES POINT IDS VALUES IN A TABLE - DONE
        //TODO CREATE AN EVAL BOX FOR DEBUGGING
        //TODO add delete voltage point button - DONE
        //TODO perform validations on voltage point like check if lat long already exists
        <!--Map Setting Script-->
        //var myCenter = new google.maps.LatLng(22.532853026644325,78.16772421874998);
        var filterCanvas;
        var filterCtx;
        var zoomRatio;
        var plottedZoom;
        var plottedCenter;
        var filterDataArray;
        var projection;
        var infowindow;
        var iconImage;
        var iconImageRed;
        var myCenter;
        var marker;
        var map;
        var ctx;
        var c;
        var xp;
        var yp;
        var ne;
        var sw;
        var latx1;
        var latx2;
        var longy1;
        var longy2;
        var lat_width;
        var long_hgt;
        var npx;
        var npy;
        var npxRatioSquare;
	var isBusy = false;
        //var sources = [[22.532853026644325, 78.16772421874998, 1.5], [21.2016592, 81.1051448, 1.1]];
        var sources = [[22.46, 73.39, 0.96, "WRLDC.PHASOR.WRDC1001", 400, "Vadodara", "OK"], [21.91, 77.34, 1.52, "WRLDC_B.PHASOR1.WRDC1160", 400, "NAME1", "OK"], [20.09, 79.11, 1.34, "WRLDC.PHASOR.WRDC0159", 400, "CHANDRAPUR", "OK"], [21.04, 75.77, 1.6, "WRLDC_B.PHASOR1.WRDC0935", 400, "JALGAON", "OK"], [24.17, 78.19, 0.91, "WRLDC.PHASOR.WRDC0336", 400, "Sagar", "OK"], [19.79, 72.72, 1.55, "WRLDC.PHASOR.WRDC0305", 400, "THANE", "OK"], [22.82, 69.53, 1.09, "WRLDC.PHASOR.WRDC0024", 400, "Kutch", "OK"], [19.95, 79.28, 1.23, "WRLDC_B.PHASOR1.WRDC1013", 400, "CHANDRAPUR", "OK"], [23.17, 72.81, 1.53, "WRLDC.PHASOR.WRDC0232", 400, "Gandhinagar", "OK"], [21.28, 79.98, 1.13, "WRLDC.PHASOR.WRDC1062", 400, "CHANDRAPUR", "OK"], [20.90, 74.76, 1.32, "WRLDC_B.PHASOR1.WRDC0857", 400, "DHULE", "OK"], [22.60, 77.75, 1.11, "WRLDC.PHASOR.WRDC0086", 400, "Hoshangabad", "OK"], [23.17, 79.98, 1.54, "WRLDC.PHASOR.WRDC0464", 400, "Jabalpur", "OK"], [21.73, 70.63, 1.48, "WRLDC_B.PHASOR1.WRDC0471", 400, "Rajkot", "OK"], [19.20, 73.00, 1.04, "WRLDC.PHASOR.WRDC0749", 400, "THANE", "OK"], [16.69, 74.22, 1.34, "WRLDC_B.PHASOR1.WRDC0584", 400, "KOLHAPUR", "OK"], [21.24, 79.09, 1.44, "WRLDC_B.PHASOR1.WRDC1121", 400, "NAGPUR", "OK"], [22.38, 82.68, 1.01, "WRLDC.PHASOR.WRDC0194", 400, "Korba", "OK"], [18.63, 74.02, 1.08, "WRLDC_B.PHASOR1.WRDC0701", 400, "PUNE", "OK"], [22.83, 69.73, 1.01, "WRLDC_B.PHASOR1.WRDC0004", 400, "Kutch", "OK"], [19.99, 73.64, 1.2, "WRLDC_B.PHASOR1.WRDC0857", 220, "NAME2", "OK"], [17.43, 73.66, 1.49, "WRLDC_B.PHASOR1.WRDC0623", 400, "SATARA", "OK"], [19.35, 73.17, 1.18, "WRLDC_B.PHASOR1.WRDC0662", 400, "THANE", "OK"], [18.84, 76.51, 1.53, "WRLDC_B.PHASOR1.WRDC0740", 400, "BEED", "OK"], [21.25, 81.62, 1.36, "WRLDC.PHASOR.WRDC1222", 400, "Raipur", "OK"], [23.82, 72.46, 1.23, "WRLDC_B.PHASOR1.WRDC0515", 400, "Mehsana", "OK"], [24.58, 80.87, 1.02, "WRLDC_B.PHASOR1.WRDC0249", 400, "Satna", "OK"], [17.68, 75.91, 1.18, "WRLDC.PHASOR.WRDC0804", 400, "SOLAPUR", "OK"], [17.65, 75.90, 1.45, "WRLDC.PHASOR.WRDC0870", 765, "NAME3", "OK"], [17.66, 75.94, 1.15, "WRLDC_B.PHASOR1.WRDC0896", 400, "SOLAPUR", "OK"], [24.03, 82.57, 1.28, "WRLDC.PHASOR.WRDC0412", 400, "Singrauli", "OK"], [24.47, 72.03, 1.32, "WRLDC_B.PHASOR1.WRDC0204", 400, "Banaskantha", "OK"]]; 
        //String for get request
        var queryStringParamsForData = sources.map(function(obj){ 
	   return obj[3];
	}).join(',');
        var alpha = 1.5;
        var transparency = 120;//between 0 - 255
        var canvasData = [];
        var normalisedCanvasData = [];
        var imageData = [];
        var minVal;
        var maxVal;
        var valDiff;
        var maxHue = 120;
        var minHue = 0;
        var maxHueToDisplay = maxHue;
        var hueDiff = maxHue - minHue; //Lets go for red color for now
        var xpsource;
        var ypsource;
        var vsource;
        var mConsole;
        var mSourceTable;
        //http://gomakethings.com/a-native-javascript-equivalent-of-jquerys-ready-method/
        //https://developer.mozilla.org/en/docs/web/api/document/readystate
        // alternative to DOMContentLoaded event
        document.onreadystatechange = function () {
            if (document.readyState == "interactive") {
                domReady();
            } else if (document.readyState == "complete") {
                //DOM load initialization function
                if(document.getElementById("filter")){
                    filterCanvas = document.createElement('canvas');
                    //filterCanvas = document.getElementById("myCanvas");
                    filterCanvas.style.width = xp;
                    filterCanvas.style.height = yp;
                    filterCanvas.setAttribute('width',xp);
                    filterCanvas.setAttribute('height',yp);
                    filterCtx = filterCanvas.getContext('2d');
                    //filterCtx.globalAlpha = 0.5;
                }
                google.maps.event.addDomListener(window, 'load', mapSourceLoaded);
            }
        };
        //Utility Functions
        function doStyling(style, tag) {
            style.display = 'block';
            style.fontSize = '0.9em';
            style.fontFamily = "Courier New";
            if (tag == 'error') {
                style.color = 'red';
            } else if (tag == 'warning') {
                style.color = '#FF8C00';
            } else if (tag == 'info') {
                style.color = 'blue';
            } else if (tag == 'success') {
                style.color = 'blue';
            }
        }
        //Utility Functions
        function WriteLineConsole(str, tag) {
            var currentDate = new Date();
            var para = document.createElement("span");
            var n = currentDate.getDate() + "/"
                    + (currentDate.getMonth() + 1) + "/"
                    + currentDate.getFullYear() + " @ "
                    + currentDate.getHours() + ":"
                    + currentDate.getMinutes() + ":"
                    + currentDate.getSeconds() + " - ";
            var node = document.createTextNode(n + str);
            para.appendChild(node);
            //mConsole.appendChild(para);
            mConsole.insertBefore(para, mConsole.firstChild);
            doStyling(para.style, tag);
        }
        //Utility Functions
        function clearConsole(str, tag) {
            mConsole.innerHTML = "";
        }
        //Utility Functions
        function addVoltPointsToTable() {
            clearTable();
            for (var i = 0; i < sources.length; i++) {
                addRow(i + 1, sources[i][5], sources[i][0], sources[i][1], sources[i][2]);
            }
        }
        //Utility Functions
        function addRow() {
            var rowCount = mSourceTable.rows.length;
            //var colCount = table.rows[0].cells.length;
            var row = mSourceTable.insertRow(rowCount);//if row to inserted at last then insert at rowCount
            for (var i = arguments.length - 1; i >= 0; i--) {
                //alert(arguments[i]);
                var newCell = row.insertCell(0);
                var t = document.createTextNode(arguments[i]);
                var s = document.createElement("span");
                s.appendChild(t);
                newCell.appendChild(s);
            }
            newCell = row.insertCell(arguments.length);
            t = document.createTextNode("Delete");
            s = document.createElement("button");
            s.appendChild(t);
            newCell.appendChild(s);
            s.onclick = function () {
                var confirmDelete = confirm("Delete the Voltage point number " + this.parentNode.parentNode.rowIndex + " ?");
                if (confirmDelete) {
                    //mSourceTable.deleteRow(this.parentNode.parentNode.rowIndex - 1);
                    sources.splice(this.parentNode.parentNode.rowIndex - 1, 1);
                    addVoltPointsToTable();
                    onMapStateChanged();
                }
            };
            //row inserted in to the table
        }
        //Utility Functions
        function clearTable() {
            mSourceTable.innerHTML = "";
        }
        //Utility Functions
        //Numeric text input listener
        //http://stackoverflow.com/questions/33251052/allow-only-numbers-and-ctrla-ctrlv-ctrlc-to-a-textbox
        function numericListener(e) {
            // Allow: backspace, delete, tab, escape, enter and .
            if ([46, 8, 9, 27, 13, 110, 190].indexOf(e.keyCode) !== -1 ||
                        // Allow: Ctrl+A
                    (e.keyCode == 65 && e.ctrlKey === true) ||
                        // Allow: Ctrl+C
                    (e.keyCode == 67 && e.ctrlKey === true) ||
                        // Allow: Ctrl+X
                    (e.keyCode == 88 && e.ctrlKey === true) ||
                        // Allow: home, end, left, right
                    (e.keyCode >= 35 && e.keyCode <= 39)) {
                // let it happen, don't do anything
                return;
            }
            // Ensure that it is a number and stop the keypress
            if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
                e.preventDefault();
            }
        }
        //Utility Functions
        function showHide(el, txt1, txt2) {
            //Toggle Display button for the table
            var div = findSibling(el, "hidingClass");
            if (div.style.display !== "none") {
                div.style.display = "none";
                el.textContent = txt1;
            } else {
                div.style.display = "block";
                el.textContent = txt2;
            }
        }
        //Utility Functions
        function findSibling(el, cls) {
            while (!el.classList.contains(cls)) {
                el = el.nextElementSibling;
            }
            return el;
        }
        //Utility Functions
        function isNumberKey(evt) {
            //charcodes info http://www.cambiaresearch.com/articles/15/javascript-key-codes
            evt = (evt) ? evt : window.event;
            var charCode = (evt.which) ? evt.which : evt.keyCode;
            if (charCode < 32 || (charCode > 47 && charCode < 58) || (charCode == 46)) {
                return true;
            }
            return false;
        }
        /*LatLong to pixel conversion function*/
        function LatLongToPixelCoordinates(latx, longy) {
            return [parseInt((xp / lat_width) * (longy - latx1)), parseInt((yp / long_hgt ) * (longy2 - latx))];
            //return [parseInt((xp/lat_width)*(latx - latx1),10), parseInt((yp/long_hgt )*(longy-longy1),10)];
        }
        /*Get all Voltage sources locations and p.u values as a [nx3] array */
        function getVoltagePoints() {
            // [[1,2],[3,4]];//items[0][0] = 1
            return sources;
        }
        //Compute Canvas Parameters - Do this if canvas measurements change
        function computeCanvasParams() {
            //get Console and SourceTable objects
            mConsole = document.getElementById("console");
            mSourceTable = document.getElementById("mSourceTable");
            //Canvas initialization
            ctx = c.getContext("2d");
            ctx.strokeStyle = 'blue';
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            //ctx.fillStyle = "blue";
            //ctx.fillStyle = "rgb(255, 0, 0)";
            //Get the Width and Length of canvas
            xp = getComputedStyle(c, null).getPropertyValue('width');
            xp = xp.substring(0, xp.length - 2);
            ctx.canvas.width = xp;
            yp = getComputedStyle(c, null).getPropertyValue('height');
            yp = yp.substring(0, yp.length - 2);
            ctx.canvas.height = yp;
            WriteLineConsole("*********************************", "warning");
            WriteLineConsole("Writing DIV dimensions in pixels");
            WriteLineConsole("Width of div is " + xp, "info");
            WriteLineConsole("Height of div is " + yp, "info");
            //WriteLineConsole("*********************************", "info");
        }
        //After the canvas bounds can be measured and when canvas bounds are changed
        function onMapStateChanged() {
            //get map bounds
            ne = map.getBounds().getNorthEast();//topRight
            sw = map.getBounds().getSouthWest();//bottomLeft
            latx1 = sw.lng();
            latx2 = ne.lng();
            longy1 = sw.lat();
            longy2 = ne.lat();
            //View Port Width in degrees
            lat_width = latx2 - latx1;
            long_hgt = longy2 - longy1;
            //No of degrees per pixel on X axis
            npx = lat_width / xp;
            //No of degrees per pixel on Y axis
            npy = long_hgt / yp;
            //npxRatio = npy/npx;
            npxRatioSquare = (npy * npy) / (npx * npx);
            sources = getVoltagePoints();
			
            WriteLineConsole("*********************************", "warning");
            WriteLineConsole("Writing DIV dimensions in degrees");
            WriteLineConsole("Width of div is " + lat_width, "info");
            WriteLineConsole("Height of div is " + long_hgt, "info");
            WriteLineConsole("Longitude bounds are " + latx1 + " and " + latx2, "info");
            WriteLineConsole("Latitude bounds are " + longy1 + " and " + longy2, "info");
            WriteLineConsole("degrees / pixel on X axis is " + npx, "info");
            WriteLineConsole("degrees / pixel on Y axis is " + npy, "info");			
            //WriteLineConsole("*********************************", "info");
            
            //Draw the filter image to the canvas
            //Reset the canvas tranasform
            filterCtx.setTransform(1, 0, 0, 1, 0, 0);
            
            //Clear filter canvas
            filterCtx.clearRect(0, 0, filterCanvas.width, filterCanvas.height);
            
            //get Map zoom and transform the filter canvas accordingly
            //We know that the canvas zoom is fit for zoom level 6 and canvas center latLong are 22.532853026644325, 78.16772421874998
            //scale the canvas to appropriate zoomRatio
            ////stub
            zoomRatio = Math.pow(2, map.getZoom()-plottedZoom);
            projection = overLayView.getProjection();
            ////var centerPixels = projection.fromLatLngToContainerPixel(plottedCenter);
            ////ctx.translate(centerPixels.x, centerPixels.y);
            ////var imageData = ctx.getImageData(0, 0, xp, yp);
            ////ctx.clearRect(0, 0, xp, yp);
            //ctx.setTransform(a, b, c, d, e, f);
            //a (m11) Horizontal scaling. b (m12) Horizontal skewing. c (m21) Vertical skewing. d (m22) Vertical scaling. e (dx) Horizontal moving. f (dy) Vertical moving. 
            //Draw the filter image at the origin context.drawImage(img,x,y,width,height);
            var offset = projection.fromLatLngToContainerPixel(plottedCenter);
            ctx.translate(xp/2 - offset.x, yp/2 - offset.y);
            ctx.scale(zoomRatio, zoomRatio);
            ////c.getContext('2d').putImageData(imageData, 0, 0);
            ctx.drawImage(c, 0, 0);
            //parseInt((xp / lat_width) * 16.202546)
            //parseInt((yp / long_hgt) * 11.969271)
            ////filterCtx.drawImage(document.getElementById("filter"), -1*document.getElementById("filter").naturalWidth/2, -1*document.getElementById("filter").naturalHeight/2);
            
            ////////var filterTopLeft = LatLongToPixelCoordinates(26.867768, 68.191580);
            ////projection = overLayView.getProjection();
            var point = projection.fromLatLngToContainerPixel(new google.maps.LatLng(26.867768, 68.191580));
            ////////filterCtx.drawImage(document.getElementById("filter"), filterTopLeft[0], filterTopLeft[1], parseInt((xp / lat_width) * 16.202546), parseInt((yp / long_hgt) * 11.969271));
            filterCtx.drawImage(document.getElementById("filter"), point.x, point.y, parseInt((xp / lat_width) * 16.202546), parseInt((yp / long_hgt) * 11.969271));
            // reset current transformation matrix to the identity matrix
            ////ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            //Get the filter data
            filterDataArray = filterCtx.getImageData(0,0,xp,yp);
            
            //Run the plotting algorithm
	    runAlgorithm();
        }
        //Run Algorithm
	function runAlgorithm(){
		plottedZoom = map.getZoom();
		plottedCenter = map.getCenter();
		/*
	             ******************Algorithm******************
	             calculate npx, npxRatioSquare which change when map bounds change
	             clear the result image data array
	             foreach source
	             calculate the per unit value of source voltage
	             get the source location in pixels
	             foreach canvaspixel
	             calcualate pixel intensity according to the formula and add it to result image data array
	             end
	             end
	             foreach result image data array pixel
	             update maximum intensity value
	             update minimum intensity value
	             end
	             calculate normalisation factor for result image data array
	             multiply each pixel of result image data array with normalisation factor to get the hue of the pixel
	             assign each pixel the hue obtained from normalised image data array
		*/
            //clear and initialize
            canvasData = [];
            for (var iter = 0; iter < xp * yp; iter++) {
                canvasData[iter] = 0;
            }
            normalisedCanvasData = [];
            //For each source
            //var xpsource; var ypsource;
            ////////var projection = overLayView.getProjection();
            var point;
            for (var i = 0; i < sources.length; i++) {
            	//skip from the for loop if sources status is not "OK"
                //var vsource = sources[i][2];
                if(sources[i][6] != "OK"){continue;}
                vsource = sources[i][2];
                point = projection.fromLatLngToContainerPixel(new google.maps.LatLng(sources[i][0], sources[i][1]));
                xpsource = point.x;
                ypsource = point.y;
                ////[xpsource, ypsource] = LatLongToPixelCoordinates(sources[i][0], sources[i][1]);
                for (var xpdest = 0; xpdest < xp; xpdest++) {
                    for (var ypdest = 0; ypdest < yp; ypdest++) {
                        //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
                        ////if xpdest and ypdest belong to filter, then calculate the intensity
                        if(filterDataArray.data[(ypdest * xp + xpdest) * 4] == 255){
                        	xpx = xpdest - xpsource;
                        	ypx = ypdest - ypsource;
                        	canvasData[(xpdest + ypdest * xp)] += vsource * Math.exp(-alpha * npx * Math.sqrt(xpx * xpx + npxRatioSquare * ypx * ypx));	
                        }
                    } //y iterator
                } //x iterator
            } //source iterator
            //Find max and min voltage value in canvasData
            minVal = 1000;
            maxVal = 0;
            for (var xpdest = 0; xpdest < xp; xpdest++) {
                for (var ypdest = 0; ypdest < yp; ypdest++) {
                    //xpdest = x axis iterator; ypdest = y axis iterator
                    if(filterDataArray.data[(ypdest * xp + xpdest) * 4] == 255){
                	var val = canvasData[(xpdest + ypdest * xp)];
	                if (val < minVal) {
	                	minVal = val;
	                } else if (val > maxVal) {
	                	maxVal = val;
	                }	
	            }
                } //y iterator
            } //x iterator
            //Do Normalisation
            //normalisedValue = hueDiff * (1 - value/(maxval-minval));
            //normalisedValue = hueDiff * (1 - value/(valDiff)); where valDiff = maxval-minval;
            valDiff = maxVal - minVal;
            for (var xpdest = 0; xpdest < xp; xpdest++) {
                for (var ypdest = 0; ypdest < yp; ypdest++) {
                    //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
                    //normalisedCanvasData[xpdest,ypdest] = hueDiff * (1 - canvasData[xpdest,ypdest]/(valDiff));//Use this for hue version
                    if(filterDataArray.data[(ypdest * xp + xpdest) * 4] == 255){
			normalisedCanvasData[(xpdest + ypdest * xp)] = hueDiff * ((canvasData[(xpdest + ypdest * xp)] - minVal) / (valDiff));//Use this for RGB version
                    }
                    
                } //y iterator
            } //x iterator
            //canvas putImageData reference - http://www.w3schools.com/tags/canvas_putimagedata.asp
            //canvas createImageData reference - http://www.w3schools.com/tags/canvas_createimagedata.asp
            //Clear Canvas Data
            canvasData = [];
            
            ctx = c.getContext("2d");
            imageData = ctx.getImageData(0, 0, xp, yp);//imageData context.getImageData(x,y,width,height);
            for (var xpdest = 0; xpdest < xp; xpdest++) {
                for (var ypdest = 0; ypdest < yp; ypdest++) {
                    //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
                    hue = maxHue - normalisedCanvasData[(xpdest + ypdest * xp)];
                    [imageData.data[(ypdest * xp + xpdest) * 4], imageData.data[(ypdest * xp + xpdest) * 4 + 1], imageData.data[(ypdest * xp + xpdest) * 4 + 2]] = hsvToRgb(hue, 1, 1);
                    //If pixel is in the filter area then display
                    if(filterDataArray.data[(ypdest * xp + xpdest) * 4] != 255){
                        imageData.data[(ypdest * xp + xpdest) * 4 + 3] = 0;
                    }else{
                    	imageData.data[(ypdest * xp + xpdest) * 4 + 3] = (hue>=maxHueToDisplay) ? 0 : transparency;
                    }
                } //y iterator
            } //x iterator
            //Clear normalisedCanvasData
            normalisedCanvasData = [];
            ctx.putImageData(imageData, 0, 0);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;//LINE WIDTH IN PIXELS
            //ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ////Commenting the source plotting by canvas since we are using markers
            /*
            for (var i = 0; i < sources.length; i++) {
            	////////var projection = overLayView.getProjection();
                var point = projection.fromLatLngToContainerPixel(new google.maps.LatLng(sources[i][0], sources[i][1]));
                ////[xpsource, ypsource] = LatLongToPixelCoordinates(sources[i][0], sources[i][1]);
                xpsource = point.x;
            	ypsource = point.y;
                if(sources[i][6] != "OK"){
                	ctx.fillStyle = "#FF0000";
                } else{
                	ctx.fillStyle = "#000000";
                }
                ctx.beginPath(); // Start the path
                ctx.arc(xpsource, ypsource, 2, 0, Math.PI * 2, false); //void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
                ctx.closePath(); // Close the path
                ctx.stroke();
                ctx.fill(); // Fill the path
            }
            */
            ////Use source status to create alternate source markers
            for (var i = 0; i < sources.length; i++) {
            	if(sources[i][6] != "OK"){
                	//Use red marker
                	sources[i][7].setIcon(iconImageRed);
                } else{
                	//Use black marker
                	sources[i][7].setIcon(iconImage);
                }
            }
		}
		//On DOM ready for manipulation, sources and assets may not have been loaded
        function domReady() {
            //initialize canvas variables
            c = document.getElementById("myCanvas");
            computeCanvasParams();
            //canvas resize listener
            new ResizeSensor(c, computeCanvasParams);
            addVoltPointsToTable();
        }
        function mapSourceLoaded() {
            //initialize map
            myCenter = new google.maps.LatLng(20.99340214457691, 77.10533410017817);
            plottedCenter = myCenter;
            var mapProp = {
                center: myCenter,
                mapTypeId: google.maps.MapTypeId.ROADMAP
            };
            map = new google.maps.Map(document.getElementById("google_map"), mapProp);
            
            overLayView = new google.maps.OverlayView();
            overLayView.draw = function() {};
            overLayView.setMap(map);
            
            //var parser = new geoXML3.parser({map: map, processStyles: true});
            //parser.parse("test.kml");
            ////Using the new technique that doesnot require the geoxml 
            ////http://stackoverflow.com/questions/8187837/google-maps-zoom-gets-overriden-when-using-a-kml-file
            var nyLayer = new google.maps.KmlLayer(
                  'https://raw.githubusercontent.com/nagasudhirpulla/GoogleMapsAPIExamples/gh-pages/test.kml',
                  {
                      suppressInfoWindows: true,
                      map: map,
                      preserveViewport: true
                  });
                  
            infowindow = new google.maps.InfoWindow();
            iconImage = {
		url: 'locationCircleIcon.png',
		// This marker is 20 pixels wide by 32 pixels high.
		size: new google.maps.Size(10, 10),
		// The origin for this image is (0, 0).
		origin: new google.maps.Point(0, 0),
		// The anchor for this image is the base of the flagpole at (0, 32).
		anchor: new google.maps.Point(5, 5)
		};
	     iconImageRed = {
		url: 'locationCircleIconRed.png',
		// This marker is 20 pixels wide by 32 pixels high.
		size: new google.maps.Size(10, 10),
		// The origin for this image is (0, 0).
		origin: new google.maps.Point(0, 0),
		// The anchor for this image is the base of the flagpole at (0, 32).
		anchor: new google.maps.Point(5, 5)
		};
            //set marker
            var marker = new google.maps.Marker({
                position: myCenter
            });
            marker.setMap(map);
            marker.addListener('click', toggleBounce);
            function toggleBounce() {
                if (marker.getAnimation() !== null) {
                    marker.setAnimation(null);
                } else {
                    marker.setAnimation(google.maps.Animation.BOUNCE);
                }
            }
            
            for (var i = 0; i < sources.length; i++) {
            	createMarker(sources[i][5], sources[i][0], sources[i][1], i);
            } //source iterator
            //add listener for map bounds being changed
            //google.maps.event.addListener(map,'bounds_changed', onMapStateChanged); // end of listener callbck
            google.maps.event.addListener(map, 'idle', onMapStateChanged);
            map.setZoom(6);
            getAlpha();
            getTrans();
            getmaxDisplayHue();
        }
        /*Change the filtered points transperency*/
        function onMapTransparencyChanged(){
        	////var imageData = ctx.getImageData(0, 0, xp, yp);//imageData context.getImageData(x,y,width,height);
	        for (var xpdest = 0; xpdest < xp; xpdest++) {
	                for (var ypdest = 0; ypdest < yp; ypdest++) {
	                    //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
	                    ////hue = maxHue - normalisedCanvasData[(xpdest + ypdest * xp)];
	                    hue = rgbToHsv(imageData.data[(ypdest * xp + xpdest) * 4], imageData.data[(ypdest * xp + xpdest) * 4 + 1], imageData.data[(ypdest * xp + xpdest) * 4 + 2])[0];
	                    //If pixel is in the filter area then display
	                    if(filterDataArray.data[(ypdest * xp + xpdest) * 4] != 255){
	                        imageData.data[(ypdest * xp + xpdest) * 4 + 3] = 0;
	                    }else{
	                    	imageData.data[(ypdest * xp + xpdest) * 4 + 3] = (hue>=maxHueToDisplay) ? 0 : transparency;
	                    }
	                } //y iterator
		} //x iterator
        	ctx.putImageData(imageData,0,0);
        }
        /*Alpha getter*/
        function getAlpha() {
            document.getElementById("alphaTextControl").value = "" + alpha;
            document.getElementById("alphaTextControl").style.color = 'blue';
        }
        /*Alpha setter*/
        function setAlpha() {
            var num = Number(document.getElementById("alphaTextControl").value);
            if (!isNaN(num)) {
                document.getElementById("alphaTextControl").style.color = 'black';
                alpha = num;
                WriteLineConsole("Set the canvas Alpha to " + num, "success");
                onMapStateChanged();
            } else {
                WriteLineConsole("Please enter numeric Input ", "error");
                document.getElementById("alphaTextControl").style.color = 'red';
            }
        }
        /*Transperency getter*/
        function getTrans() {
            document.getElementById("transControl").value = "" + transparency;
            document.getElementById("transControl").style.color = 'blue';
        }
        /*Transperency setter*/
        function setTrans() {
            var num = Number(document.getElementById("transControl").value);
            if (!isNaN(num) && num>=0 && num<=255) {
                document.getElementById("transControl").style.color = 'black';
                WriteLineConsole("Set the canvas Transperency to " + num, "success");
                transparency = num;
                ////onMapStateChanged();
                onMapTransparencyChanged();
            } else {
                WriteLineConsole("Please enter numeric Input between 0 and 255", "error");
                document.getElementById("transControl").style.color = 'red';
            }
        }
	/*MaxDisplayHue getter*/
        function getmaxDisplayHue() {
            document.getElementById("maxDisplayHueControl").value = "" + maxHueToDisplay;
            document.getElementById("maxDisplayHueControl").style.color = 'blue';
        }
        /*MaxDisplayHue setter*/
        function setmaxDisplayHue() {
            var num = Number(document.getElementById("maxDisplayHueControl").value);
            if (!isNaN(num) && num>=0 && num<=255) {
                document.getElementById("maxDisplayHueControl").style.color = 'black';
                WriteLineConsole("Set the canvas Max HueToDisplay to " + num, "success");
                maxHueToDisplay = num;
                ////onMapStateChanged();
                onMapTransparencyChanged();
            } else {
                WriteLineConsole("Please enter numeric Input between 0 and 255", "error");
                document.getElementById("maxDisplayHueControl").style.color = 'red';
            }
        }
        /*
         * HSV to RGB color conversion
         *
         * H runs from 0 to 360 degrees
         * S and V run from 0 to 1
         *
         * Ported from the excellent java algorithm by Eugene Vishnevsky at:
         * http://www.cs.rit.edu/~ncs/color/t_convert.html
         */
        function hsvToRgb(h, s, v) {
            var r, g, b;
            var i;
            var f, p, q, t;
            // Make sure our arguments stay in-range
            h = Math.max(0, Math.min(360, h));
            ////s = Math.max(0, Math.min(1, s));
            ////v = Math.max(0, Math.min(1, v));
            /****if(s == 0) {
					// Achromatic (grey)
					r = g = b = v;
					return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
					}****/
            h /= 60; // sector 0 to 5
            i = Math.floor(h);
            f = h - i; // factorial part of h
            p = v * (1 - s);
            q = v * (1 - s * f);
            t = v * (1 - s * (1 - f));
            switch (i) {
                case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;
                case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;
                case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;
                case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;
                case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;
                default: // case 5:
                    r = v;
                    g = p;
                    b = q;
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        /*
         * RGB to HSV color conversion
         http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
        */
        function rgbToHsv(r, g, b){
	    r = r/255, g = g/255, b = b/255;
	    var max = Math.max(r, g, b), min = Math.min(r, g, b);
	    var h, s, v = max;
	
	    var d = max - min;
	    s = max == 0 ? 0 : d / max;
	
	    if(max == min){
	        h = 0; // achromatic
	    }else{
	        switch(max){
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }
	        h *= 60;
	    }
	    return [h, s, v];
	}
	
        // Utility Function to create a marker
	function createMarker(add,lat,lng,sourceIterator) {
		var contentString = add;
		var marker = new google.maps.Marker({
		 position: new google.maps.LatLng(lat,lng),
		 map: map,
		 icon: iconImage,
		 zIndex: 1000
		});
		google.maps.event.addListener(marker, 'click', function() {
		 infowindow.setContent(contentString); 
		 infowindow.open(map,marker);
		});
		//Assign the marker to the sources array
		sources[sourceIterator][7] = marker;
	}
      
        //Utility functions
        function addVoltPoint() {
            var newName = document.getElementById("newVoltPointName").value;
            var newLat = document.getElementById("newVoltPointLat").value;
            var newLong = document.getElementById("newVoltPointLong").value;
            var newVal = document.getElementById("newVoltPointVal").value;
            sources.push([newLat, newLong, newVal]);
            //TODO perform validations
            addVoltPointsToTable();
            onMapStateChanged();
            document.getElementById("newVoltPointName").value = "";
            document.getElementById("newVoltPointLat").value = "";
            document.getElementById("newVoltPointLong").value = "";
            document.getElementById("newVoltPointVal").value = "";
        }
		
		var timingVar;
		//Timing function	
		function startFetching(){
			pauseFetching();
			WriteLineConsole("Starting Server Data Fetch","info")
			timingVar = setInterval(getFromPointsDataServer, 1000);
		}
		//Timing function
		function pauseFetching(){
			WriteLineConsole("Pausing Server Data Fetch","warning")
			clearInterval(timingVar);
		}
		//Timing function
		function getFromServer(){
			var point = "WRLDC.PHASOR.WRDC0783";
			$.get("http://localhost:4542/values?dnapoint="+point,function(data, status){
				if(status="success"){
					//console.log(JSON.parse(data));
					console.log(data);						
				}				
			});
		}
		//Timing function
		function getFromServerTest(){
			if(isBusy){return;}
			isBusy = true;
			//Math.random() returns random number between 0 and 1
			for(var i=0;i<sources.length;i++){
				sources[i][2] = 0.9 + Math.random();
			}
			runAlgorithm();
			isBusy = false;
		}
		//Timing function
		function getFromPointsDataServer(){
			if(isBusy){return;}
			isBusy = true;
			$.get("http://localhost:4542/values?dnapoints="+queryStringParamsForData,function(data, status){
				if(status="success"){
					//console.log(JSON.parse(data));
					//console.log(data);
					//We get pointsArray in the order of sources Array
					var pointsArray = JSON.parse(data);
					//MODIFY THE sources ARRAY from pointsArray
					for(var i = 0; i < pointsArray.result.length; i++){
						sources[i][2] = (pointsArray.result[i].value*1.73205080757)/sources[i][4];
						sources[i][6] = pointsArray.result[i]["status"];
					}
					//For now we are just logging the data fetched from server
					//console.log(pointsArray);
					console.log(JSON.stringify(pointsArray, null, '\t'));
					
					//RUN the plotting algorithm
					runAlgorithm();
					isBusy = false;
				}				
			});
		}
    </script>
</head>
<body>
<img id="filter" src="filter.png" alt="No Image Available" style="display: none">
<div id="wrapper">
    <div id="google_map" style="width:100%;height:100%;"></div>
    <canvas id="myCanvas">Your browser does not support the HTML5 canvas tag.</canvas>
</div>
<div id="controlInputs" style="margin:10px 5px 5px 10px;"><!--top right bottom left-->
	<button onclick="startFetching()">StartFetching</button>
	<button onclick="pauseFetching()">StopFetching</button><br><br>
    <h3 class="showHideButton" onclick="showHide(this,'> Voltage Points','^ Voltage Points')" > ^ Voltage Points</h3><br>
    <div class="hidingClass" style="display:block;margin-top:5px">
        <table>
            <thead>
            <tr>
                <td>SNo</td>
                <td>Name</td>
                <td>Latitude</td>
                <td>Longitude</td>
                <td>Value</td>
            </tr>
            </thead>
            <tbody id="mSourceTable"></tbody>
        </table>
        <button onclick="addVoltPointsToTable()">Refresh Table</button>
        <button onclick="clearTable()">Clear Table</button>
        <br><br>
        <input placeholder="Name" id="newVoltPointName" type="text"/>
        <input placeholder="Latitude degrees" id="newVoltPointLat" type="number"/>
        <input placeholder="Longitude degrees" id="newVoltPointLong" type="number"/>
        <input placeholder="Per Unit Value" id="newVoltPointVal" type="number"/>
        <button onclick="addVoltPoint()">AddVoltagePoint</button>
    </div><br>

    <h3 class="showHideButton" onclick="showHide(this,'> Alpha','^ Alpha')" > > Alpha</h3><br>
    <div class="hidingClass" style="display:none;margin-top:5px">
        <input id="alphaTextControl" style="width:50px;" type="text" onkeypress="return isNumberKey()"/>
        <button onclick="getAlpha()" style="margin:0px 10px;">GetAlpha</button>
        <button onclick="setAlpha()">SetAlpha</button>
    </div><br>

    <h3 class="showHideButton" onclick="showHide(this,'> Opacity','^ Opacity')" > > Opacity</h3><br>
    <div class="hidingClass" style="display:none;margin-top:5px">
        <input id="transControl" style="width:50px;" type="text" onkeypress="return isNumberKey()"/>
        <!-- <input id="alphaTextControl" style="width:50px;" type="text" onkeydown="return numericListener()" /> -->
        <button onclick="getTrans()" style="margin:0px 10px;">GetOpacity</button>
        <button onclick="setTrans()">SetOpacity</button>
    </div><br>

    <h3 class="showHideButton" onclick="showHide(this,'> MaxDisplayHue','^ MaxDisplayHue')" > > MaxDisplayHue</h3><br>
    <div class="hidingClass" style="display:none;margin-top:5px">
        <input id="maxDisplayHueControl" style="width:50px;" type="text" onkeypress="return isNumberKey()"/>
        <!-- <input id="alphaTextControl" style="width:50px;" type="text" onkeydown="return numericListener()" /> -->
        <button onclick="getmaxDisplayHue()" style="margin:0px 10px;">GetMaxDisplayHue</button>
        <button onclick="setmaxDisplayHue()">SetMaxDisplayHue</button>
    </div><br>
    
    <h3 class="showHideButton" onclick="showHide(this,'> Console','^ Console')" > > Console</h3><br>
    <div class="hidingClass" style="display:none;margin-top:5px">
        <div id="console" style="border: 1px solid black;width: 95%;height: 400px;overflow: scroll;">
        </div>
        <button onclick="clearConsole()">ClearConsole</button>
    </div><br>
</div>
<!-- Do stuff after a timeout clearing previous timeouts - http://stackoverflow.com/questions/9252493/google-maps-event-addlistenermap-idle-function-is-it-possible-to-specif -->
<!-- A complete interactive experience of google maps API- http://gmaps-samples-v3.googlecode.com/svn/trunk/map_events/map_events.html -->
</body>
</html>
